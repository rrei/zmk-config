// ZMK mouse emulation params: default movement and scrolling speed. These must be
// defined before including `dt-bindings/zmk/pointing.h`.
#define ZMK_POINTING_DEFAULT_MOVE_VAL 1800
#define ZMK_POINTING_DEFAULT_SCRL_VAL 22

// Now we import all the ZMK stuff and the above overrides get applied correctly.
#include <input/processors.dtsi>
#include <behaviors.dtsi>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/pointing.h>
#include <dt-bindings/zmk/modifiers.h>

// Define names for layers instead of using the numbers directly.
#define BASE 0
#define EXT 1
#define NAV 2
#define SYS 3

// These are useful for defining positional hold-tap behaviours (see HRM macro below).
#define LEFT_HALF_KEYS   0 1 2 3 4  10 11 12 13 14  20 21 22 23 24  30 31 32
#define RIGHT_HALF_KEYS  5 6 7 8 9  15 16 17 18 19  25 26 27 28 29  33 34 35

// (heavily) Parametrised macros for DRY combo definitions.
#define COMBO(NAME, KEY, LAYERS, POSITIONS, REQUIRE_PRIOR_IDLE, TIMEOUT) NAME { \
    bindings = <&kp KEY>; \
    layers = <LAYERS>; \
    key-positions = <POSITIONS>; \
    require-prior-idle-ms = <REQUIRE_PRIOR_IDLE>; \
    timeout-ms = <TIMEOUT>; \
    slow-release; \
}
#define COMBO_DEFAULT(N, K, L, P) COMBO(N, K, L, P, 70, 35)
#define COMBO_FAST(N, K, L, P) COMBO(N, K, L, P, 35, 35)

// Flavour and timing overrides for builtin hold-tap behaviours (&mt and &lt).
#define HOLD_TAP_OVERRIDES(NODE) NODE { \
    flavor = "balanced"; \
    require-prior-idle-ms = <100>; \
    tapping-term-ms = <200>; \
    quick-tap-ms = <300>; \
}

// "Timeless" homerow mods with positional hold-trigger keys (&hr and &hl).
#define HRM(NAME, HOLD_TRIGGER_KEYS) NAME: NAME { \
    compatible = "zmk,behavior-hold-tap"; \
    #binding-cells = <2>; \
    bindings = <&kp>, <&kp>; \
    flavor = "balanced"; \
    require-prior-idle-ms = <100>; \
    tapping-term-ms = <200>; \
    quick-tap-ms = <300>; \
    hold-trigger-key-positions = <HOLD_TRIGGER_KEYS>; \
    hold-trigger-on-release; \
}


/ {
    chosen {
        zmk,physical-layout = &foostan_corne_5col_layout;
        zmk,matrix-transform = &five_column_transform;
    };

    // The following visual representation of the keymap layout is meant to be used as
    // an aid when editing the keymap (especially combos). My keyboard is a 5-column
    // Corne Choc Wireless from Typeractive.
    //
    // IMPORTANT: I will only be using the two inner thumb keys, leaving keys 30 and 35
    // unused (they're covered by the switch plate I've 3D printed). The firmware will
    // still see them as valid keys (mapped to `&none` and never pressed), but they need
    // to be taken into account when defining key positions, as they will affect the
    // indices of the remaining keys.
    //
    // ┌────┬────┬────┬────┬────┐                 ┌────┬────┬────┬────┬────┐
    // │  0 │  1 │  2 │  3 │  4 │                 │  5 │  6 │  7 │  8 │  9 │
    // ├────┼────┼────┼────┼────┤                 ├────┼────┼────┼────┼────┤
    // │ 10 │ 11 │ 12 │ 13 │ 14 │                 │ 15 │ 16 │ 17 │ 18 │ 19 │
    // ├────┼────┼────┼────┼────┤                 ├────┼────┼────┼────┼────┤
    // │ 20 │ 21 │ 22 │ 23 │ 24 │                 │ 25 │ 26 │ 27 │ 28 │ 29 │
    // └────┴────┴────┼────┼────┼────┐       ┌────┼────┼────┼────┴────┴────┘
    //                │ 30 │ 31 │ 32 │       │ 33 │ 34 │ 35 │
    //                └────┴────┴────┘       └────┴────┴────┘
    combos {
        compatible = "zmk,combos";

        // Easy to pull combos for very common keys: tab, backspace, delete, enter,
        // escape, space. These use the two strongest fingers (index and middle) on each
        // side of the keyboard, either in their home position or one key away.
        //
        // The combo for SPACE uses a reduced "require-prior-idle" value because I need
        // to be able to use it while typing at normal speed. Otherwise I'd have a
        // noticeable wait after every word to be able to type a space and continue
        // typing.
        COMBO_DEFAULT(kp_tab, TAB, BASE EXT, 2 3);
        COMBO_DEFAULT(kp_bspc, BSPC, BASE EXT, 12 13);
        COMBO_DEFAULT(kp_del, DEL, BASE EXT, 13 14);
        COMBO_DEFAULT(kp_ret, RET, BASE EXT, 6 7);
        COMBO_DEFAULT(kp_esc, ESC, BASE EXT, 15 16);
        COMBO_FAST(kp_spc, SPC, BASE EXT, 16 17);

        // The NUBS (non-US backslash) key is normally useless for writing but for some
        // reason Apple decided to put one on my laptop so... in order to make it
        // useful, I bound it to iterm2's hotkey window, which I use frequently. I'm
        // adding one combo for each side of the keyboard.
        COMBO_DEFAULT(kp_nubs_l, NUBS, BASE EXT, 22 23);
        COMBO_DEFAULT(kp_nubs_r, NUBS, BASE EXT, 26 27);

        // F11 and F12 keys couldn't fit the keyboard (only 5 columns on each side).
        COMBO_DEFAULT(kp_f11, F11, EXT, 7 8);
        COMBO_DEFAULT(kp_f12, F12, EXT, 8 9);
    };

    keymap {
        compatible = "zmk,keymap";

        base {
            bindings = <
  &kp Q        &kp W        &hl LALT E  &kp R           &kp T           &kp Y            &kp U          &hr RALT I     &kp O        &kp P
  &hl LSHFT A  &hl LCTRL S  &lt NAV D   &hl LCMD F      &kp G           &kp H            &hr RCMD J     &lt NAV K      &hr RCTRL L  &hr RSHFT SEMI
  &kp Z        &kp X        &lt EXT C   &kp V           &kp B           &kp N            &kp M          &lt EXT COMMA  &kp PERIOD   &kp SLASH
                            &none       &mt LALT GRAVE  &mt LCMD SQT    &mt RSHFT MINUS  &lt EXT EQUAL  &none
            >;
        };

        extended {
            bindings = <
  &kp F1        &kp F2        &hl LALT F3  &kp F4         &kp F5           &kp F6          &kp F7        &hr RALT F8  &kp F9        &kp F10
  &hl LSHFT N1  &hl LCTRL N2  &lt NAV N3   &hl LCMD N4    &kp N5           &kp N6          &hr RCMD N7   &lt NAV N8   &hr RCTRL N9  &hr RSHFT N0
  &trans        &trans        &trans       &trans         &trans           &trans          &trans        &trans       &trans        &kp BACKSLASH
                              &none        &mt LALT LPAR  &mt LCMD RPAR    &mt RSHFT LBKT  &lt EXT RBKT  &none
            >;
        };

        navigation {
            bindings = <
  &trans  &msc SCRL_RIGHT  &mmv MOVE_UP    &msc SCRL_LEFT   &msc SCRL_DOWN    &kp PG_UP       &kp HOME         &kp UP    &kp END    &trans
  &trans  &mmv MOVE_LEFT   &mmv MOVE_DOWN  &mmv MOVE_RIGHT  &msc SCRL_UP      &kp PG_DN       &kp LEFT         &kp DOWN  &kp RIGHT  &trans
  &trans  &trans           &trans          &mkp LCLK        &mkp RCLK         &mkp RCLK       &mkp LCLK        &trans    &trans     &kp BACKSLASH
                           &none           &mt LALT LPAR    &mt LCMD RPAR     &mt RSHFT LBKT  &lt EXT RBKT     &none
            >;
        };

        system {
            bindings = <
  &bt BT_SEL 0  &bt BT_SEL 1  &bt BT_SEL 2  &bt BT_SEL 3    &bt BT_SEL 4    &none      &none       &none     &none      &bt_clr 0 0
  &kp LSHFT     &none         &kp C_BRI_UP  &kp C_VOL_UP    &none           &none      &kp C_PREV  &kp C_PP  &kp C_NEXT &kp RSHFT
  &none         &none         &kp C_BRI_DN  &kp C_VOL_DN    &none           &none      &none       &none     &none      &none
                              &none         &kp C_MUTE      &none           &kp RSHFT  &none       &none
            >;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        mo_sys {
            if-layers = <EXT NAV>;
            then-layer = <SYS>;
        };
    };

    behaviors {
        HRM(hl, RIGHT_HALF_KEYS);
        HRM(hr, LEFT_HALF_KEYS);

        bt_clr: bt_clr {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "tap-preferred";
            tapping-term-ms = <3000>;
            bindings = <&mm_bt_clr>, <&none>;
        };

        mm_bt_clr: mm_bt_clr {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&bt BT_CLR>, <&bt BT_CLR_ALL>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
    };
};

HOLD_TAP_OVERRIDES(&mt);
HOLD_TAP_OVERRIDES(&lt);

&kscan0 { wakeup-source; };
