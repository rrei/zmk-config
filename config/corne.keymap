// ZMK mouse emulation params: default movement and scrolling speed. These must be
// defined before including `dt-bindings/zmk/pointing.h`.
#define ZMK_POINTING_DEFAULT_MOVE_VAL 1800
#define ZMK_POINTING_DEFAULT_SCRL_VAL 22

// Now we import all the ZMK stuff and the above overrides get applied correctly.
#include <input/processors.dtsi>
#include <behaviors.dtsi>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/pointing.h>
#include <dt-bindings/zmk/modifiers.h>

// Define names for layers instead of using the numbers directly.
#define BASE 0
#define EXT 1
#define NAV 2
#define SYS 3

// These are useful for defining positional hold-tap behaviours (see HRM macro below).
#define LEFT_HALF_KEYS   0 1 2 3 4  10 11 12 13 14  20 21 22 23 24  30 31 32
#define RIGHT_HALF_KEYS  5 6 7 8 9  15 16 17 18 19  25 26 27 28 29  33 34 35

// Parametrised macros for DRY combo definitions:
// - fast combos have tighter timeout to avoid interfering with typing
// - slow combos involve thumb keys and are therefore given a longer timeout
#define COMBO(NAME, BINDINGS, POSITIONS, TIMEOUT) NAME { \
    layers = <BASE EXT>; \
    bindings = <BINDINGS>; \
    key-positions = <POSITIONS>; \
    timeout-ms = <TIMEOUT>; \
    require-prior-idle-ms = <100>; \
    slow-release; \
}
#define FAST_COMBO(N, B, P) COMBO(N, B, P, 35)
#define SLOW_COMBO(N, B, P) COMBO(N, B, P, 70)

// Flavour and timing overrides for builtin hold-tap behaviours (&mt and &lt).
#define HOLD_TAP_OVERRIDES(NODE) NODE { \
    flavor = "balanced"; \
    require-prior-idle-ms = <100>; \
    tapping-term-ms = <200>; \
    quick-tap-ms = <300>; \
}

// "Timeless" homerow mods with positional hold-trigger keys (&hr and &hl).
#define HRM(NAME, HOLD_TRIGGER_KEYS) NAME: NAME { \
    compatible = "zmk,behavior-hold-tap"; \
    #binding-cells = <2>; \
    bindings = <&kp>, <&kp>; \
    flavor = "balanced"; \
    require-prior-idle-ms = <100>; \
    tapping-term-ms = <400>; \
    quick-tap-ms = <300>; \
    hold-trigger-key-positions = <HOLD_TRIGGER_KEYS>; \
    hold-trigger-on-release; \
}


/ {
    chosen {
        zmk,physical-layout = &foostan_corne_5col_layout;
        zmk,matrix-transform = &five_column_transform;
    };

    // The following visual representation of the keymap layout is meant to be used as
    // an aid when editing the keymap (especially combos). My keyboard is a 5-column
    // Corne Choc Wireless from Typeractive.
    //
    // IMPORTANT: I will only be using the two inner thumb keys, leaving keys 30 and 35
    // unused (they're covered by the switch plate I've 3D printed). The firmware will
    // still see them as valid keys (mapped to `&none` and never pressed), but they need
    // to be taken into account when defining key positions, as they will affect the
    // indices of the remaining keys.
    //
    // ┌────┬────┬────┬────┬────┐                 ┌────┬────┬────┬────┬────┐
    // │  0 │  1 │  2 │  3 │  4 │                 │  5 │  6 │  7 │  8 │  9 │
    // ├────┼────┼────┼────┼────┤                 ├────┼────┼────┼────┼────┤
    // │ 10 │ 11 │ 12 │ 13 │ 14 │                 │ 15 │ 16 │ 17 │ 18 │ 19 │
    // ├────┼────┼────┼────┼────┤                 ├────┼────┼────┼────┼────┤
    // │ 20 │ 21 │ 22 │ 23 │ 24 │                 │ 25 │ 26 │ 27 │ 28 │ 29 │
    // └────┴────┴────┼────┼────┼────┐       ┌────┼────┼────┼────┴────┴────┘
    //                │ 30 │ 31 │ 32 │       │ 33 │ 34 │ 35 │
    //                └────┴────┴────┘       └────┴────┴────┘


    combos {
        compatible = "zmk,combos";

        // Fast combos for very common keys: tab, backspace, delete, enter, escape, space.
        FAST_COMBO(kp_tab_fast, &kp TAB, 2 3);
        FAST_COMBO(kp_bspc_fast, &kp BSPC, 12 13);
        FAST_COMBO(kp_del_fast, &kp DEL, 13 14);

        FAST_COMBO(kp_ret_fast, &kp RET, 6 7);
        FAST_COMBO(kp_esc_fast, &kp ESC, 15 16);
        FAST_COMBO(kp_spc_fast, &kp SPACE, 16 17);

        // Slow alternatives to the fast combos above.
        SLOW_COMBO(kp_tab_slow, &kp TAB, 2 31);
        SLOW_COMBO(kp_bspc_slow, &kp BSPC, 12 31);
        SLOW_COMBO(kp_del_slow, &kp DEL, 13 31);

        SLOW_COMBO(kp_ret_slow, &kp RET, 7 34);
        SLOW_COMBO(kp_esc_slow, &kp ESC, 16 34);
        SLOW_COMBO(kp_spc_slow, &kp SPACE, 17 34);

        // EXT and NAV layer activation.
        SLOW_COMBO(mo_nav_l, &mo NAV, 32 12);
        SLOW_COMBO(mo_nav_r, &mo NAV, 33 17);
        SLOW_COMBO(mo_ext_l, &mo EXT, 32 13);
        SLOW_COMBO(mo_ext_r, &mo EXT, 33 16);
    };

    keymap {
        compatible = "zmk,keymap";

        base {
            bindings = <
  &kp Q        &kp W        &lt NAV E   &lt EXT R       &kp T           &kp Y            &lt EXT U      &lt NAV I   &kp O        &kp P
  &hl LSHFT A  &hl LCTRL S  &hl LALT D  &hl LCMD F      &kp G           &kp H            &hr RCMD J     &hr RALT K  &hr RCTRL L  &hr RSHFT SEMI
  &kp Z        &kp X        &kp C       &kp V           &kp B           &kp N            &kp M          &kp COMMA   &kp PERIOD   &kp SLASH
                            &none       &mt LALT GRAVE  &mt LCMD SQT    &mt RSHFT MINUS  &lt EXT EQUAL  &none
            >;
        };

        extended {
            bindings = <
  &kp F1        &kp F2        &lt NAV F3   &lt EXT F4     &kp F5           &kp F6          &lt EXT F7    &lt NAV F8   &kp F9        &kp F10
  &hl LSHFT N1  &hl LCTRL N2  &hl LALT N3  &hl LCMD N4    &kp N5           &kp N6          &hr RCMD N7   &hr RALT N8  &hr RCTRL N9  &hr RSHFT N0
  &trans        &trans        &trans       &trans         &trans           &trans          &trans        &trans       &trans        &kp BACKSLASH
                              &none        &mt LALT LPAR  &mt LCMD RPAR    &mt RSHFT LBKT  &lt EXT RBKT  &none
            >;
        };

        navigation {
            bindings = <
  &trans  &msc SCRL_RIGHT  &mmv MOVE_UP    &msc SCRL_LEFT   &msc SCRL_DOWN    &kp PG_UP       &kp HOME         &kp UP    &kp END    &trans
  &trans  &mmv MOVE_LEFT   &mmv MOVE_DOWN  &mmv MOVE_RIGHT  &msc SCRL_UP      &kp PG_DN       &kp LEFT         &kp DOWN  &kp RIGHT  &trans
  &trans  &trans           &trans          &mkp LCLK        &mkp RCLK         &mkp RCLK       &mkp LCLK        &trans    &trans     &kp BACKSLASH
                           &none           &mt LALT LPAR    &mt LCMD RPAR     &mt RSHFT LBKT  &lt EXT RBKT     &none
            >;
        };

        system {
            bindings = <
  &bt BT_SEL 0  &bt BT_SEL 1  &bt BT_SEL 2  &bt BT_SEL 3  &bt BT_SEL 4    &none      &none       &none     &none      &bt_clr 0 0
  &kp LSHFT     &none         &kp C_BRI_UP  &kp C_VOL_UP  &none           &none      &kp C_PREV  &kp C_PP  &kp C_NEXT &kp RSHFT
  &none         &none         &kp C_BRI_DN  &kp C_VOL_DN  &none           &none      &none       &none     &none      &none
                              &none         &none         &none           &kp RSHFT  &none       &none
            >;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        mo_sys {
            if-layers = <EXT NAV>;
            then-layer = <SYS>;
        };
    };


    behaviors {
        HRM(hl, RIGHT_HALF_KEYS);
        HRM(hr, LEFT_HALF_KEYS);

        bt_clr: bt_clr {
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "tap-preferred";
            tapping-term-ms = <3000>;
            bindings = <&mm_bt_clr>, <&none>;
        };

        mm_bt_clr: mm_bt_clr {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&bt BT_CLR>, <&bt BT_CLR_ALL>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
    };
};

HOLD_TAP_OVERRIDES(&mt);
HOLD_TAP_OVERRIDES(&lt);

&kscan0 { wakeup-source; };
